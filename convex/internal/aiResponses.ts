import { internalMutation, internalQuery, internalAction } from "../_generated/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";

// Create an agent job
export const createJob = internalMutation({
  args: {
    taskId: v.optional(v.id("tasks")),
    pullRequestId: v.optional(v.id("pullRequests")),
    type: v.union(
      v.literal("chat_response"),
      v.literal("task_analysis"),
      v.literal("code_review"),
      v.literal("auto_fix")
    ),
    input: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const jobId = await ctx.db.insert("agentJobs", {
      taskId: args.taskId,
      pullRequestId: args.pullRequestId,
      type: args.type,
      status: "pending",
      input: args.input,
      createdAt: Date.now(),
    });

    return jobId;
  },
});

// Update job status to running
export const startJob = internalMutation({
  args: { jobId: v.id("agentJobs") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.jobId, {
      status: "running",
      startedAt: Date.now(),
    });
  },
});

// Complete a job successfully
export const completeJob = internalMutation({
  args: {
    jobId: v.id("agentJobs"),
    output: v.any(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.jobId, {
      status: "completed",
      output: args.output,
      completedAt: Date.now(),
    });
  },
});

// Fail a job
export const failJob = internalMutation({
  args: {
    jobId: v.id("agentJobs"),
    errorMessage: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.jobId, {
      status: "failed",
      errorMessage: args.errorMessage,
      completedAt: Date.now(),
    });
  },
});

// Load chat context for AI
export const loadChatContext = internalQuery({
  args: {
    projectId: v.optional(v.id("projects")),
    taskId: v.optional(v.id("tasks")),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 20;
    let messages: Array<{
      _id: any;
      sender: "ai" | "user";
      text: string;
      createdAt: number;
    }> = [];

    if (args.taskId) {
      messages = await ctx.db
        .query("chatMessages")
        .withIndex("by_task", (q) => q.eq("taskId", args.taskId))
        .collect();
    } else if (args.projectId) {
      const allMessages = await ctx.db
        .query("chatMessages")
        .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
        .collect();
      messages = allMessages.filter((m) => m.taskId === undefined);
    }

    const sorted = messages.sort((a, b) => a.createdAt - b.createdAt);
    return sorted.slice(-limit);
  },
});

// Write AI chat response
export const writeChatResponse = internalMutation({
  args: {
    projectId: v.optional(v.id("projects")),
    taskId: v.optional(v.id("tasks")),
    text: v.string(),
  },
  handler: async (ctx, args) => {
    // Get projectId from task if only taskId is provided
    let projectId = args.projectId;
    if (args.taskId && !projectId) {
      const task = await ctx.db.get(args.taskId);
      projectId = task?.projectId;
    }

    const messageId = await ctx.db.insert("chatMessages", {
      projectId,
      taskId: args.taskId,
      sender: "ai",
      text: args.text,
      createdAt: Date.now(),
    });

    return messageId;
  },
});

// Generate chat response (would call external AI API in production)
export const generateChatResponse = internalAction({
  args: {
    projectId: v.optional(v.id("projects")),
    taskId: v.optional(v.id("tasks")),
    userMessage: v.string(),
  },
  handler: async (ctx, args) => {
    // Create a job record
    const jobId = await ctx.runMutation(internal.internal.aiResponses.createJob, {
      taskId: args.taskId,
      type: "chat_response",
      input: { message: args.userMessage },
    });

    await ctx.runMutation(internal.internal.aiResponses.startJob, { jobId });

    try {
      // Load chat context
      const context = await ctx.runQuery(internal.internal.aiResponses.loadChatContext, {
        projectId: args.projectId,
        taskId: args.taskId,
        limit: 10,
      });

      // In production, this would call an external AI API
      // For now, generate a placeholder response
      const response = `I received your message: "${args.userMessage}". This is a placeholder AI response. In production, this would be generated by calling an external AI API with the conversation context.`;

      // Write the response
      await ctx.runMutation(internal.internal.aiResponses.writeChatResponse, {
        projectId: args.projectId,
        taskId: args.taskId,
        text: response,
      });

      // Mark job as complete
      await ctx.runMutation(internal.internal.aiResponses.completeJob, {
        jobId,
        output: { response },
      });

      return { success: true, response };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      await ctx.runMutation(internal.internal.aiResponses.failJob, {
        jobId,
        errorMessage: message,
      });
      throw error;
    }
  },
});

// Analyze task and generate acceptance criteria/tests
export const analyzeTask = internalAction({
  args: { taskId: v.id("tasks") },
  handler: async (ctx, args) => {
    const jobId = await ctx.runMutation(internal.internal.aiResponses.createJob, {
      taskId: args.taskId,
      type: "task_analysis",
    });

    await ctx.runMutation(internal.internal.aiResponses.startJob, { jobId });

    try {
      // In production, this would:
      // 1. Load task details
      // 2. Call AI API to analyze and generate suggestions
      // 3. Create acceptance criteria and tests

      // Placeholder implementation
      const result = {
        acceptanceCriteria: [
          "Feature should work as expected",
          "All edge cases should be handled",
          "Code should be well-documented",
        ],
        suggestedTests: [
          "Test basic functionality",
          "Test error handling",
          "Test edge cases",
        ],
      };

      await ctx.runMutation(internal.internal.aiResponses.completeJob, {
        jobId,
        output: result,
      });

      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      await ctx.runMutation(internal.internal.aiResponses.failJob, {
        jobId,
        errorMessage: message,
      });
      throw error;
    }
  },
});

// Run AI code review on PR
export const runCodeReview = internalAction({
  args: { pullRequestId: v.id("pullRequests") },
  handler: async (ctx, args) => {
    const jobId = await ctx.runMutation(internal.internal.aiResponses.createJob, {
      pullRequestId: args.pullRequestId,
      type: "code_review",
    });

    await ctx.runMutation(internal.internal.aiResponses.startJob, { jobId });

    try {
      // In production, this would:
      // 1. Fetch PR diff from GitHub
      // 2. Call AI API to review code
      // 3. Create issues/comments based on findings

      // Placeholder implementation
      const result = {
        reviewComplete: true,
        issuesFound: 0,
        summary: "Code review placeholder - would analyze PR diff in production",
      };

      await ctx.runMutation(internal.internal.aiResponses.completeJob, {
        jobId,
        output: result,
      });

      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      await ctx.runMutation(internal.internal.aiResponses.failJob, {
        jobId,
        errorMessage: message,
      });
      throw error;
    }
  },
});

// Generate auto-fix for an issue
export const autoFixIssue = internalAction({
  args: { issueId: v.id("prIssues") },
  handler: async (ctx, args) => {
    const jobId = await ctx.runMutation(internal.internal.aiResponses.createJob, {
      type: "auto_fix",
      input: { issueId: args.issueId },
    });

    await ctx.runMutation(internal.internal.aiResponses.startJob, { jobId });

    try {
      // In production, this would:
      // 1. Load issue details
      // 2. Call AI API to generate fix
      // 3. Return suggested code changes

      // Placeholder implementation
      const result = {
        fixGenerated: true,
        suggestion: "// Placeholder fix suggestion",
      };

      await ctx.runMutation(internal.internal.aiResponses.completeJob, {
        jobId,
        output: result,
      });

      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      await ctx.runMutation(internal.internal.aiResponses.failJob, {
        jobId,
        errorMessage: message,
      });
      throw error;
    }
  },
});
